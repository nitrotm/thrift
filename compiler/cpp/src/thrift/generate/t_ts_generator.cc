/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#include <map>
#include <string>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <limits>
#include <vector>
#include <list>
#include <cassert>

#include <stdlib.h>
#include <sys/stat.h>
#include <math.h>
#include <sstream>
#include "thrift/platform.h"
#include "thrift/version.h"

using std::map;
using std::ostream;
using std::ostringstream;
using std::string;
using std::stringstream;
using std::vector;

static const string endl = "\n"; // avoid ostream << std::endl flushes

#include "thrift/generate/t_oop_generator.h"


/**
 * TypeScript code generator.
 */
class t_ts_generator : public t_oop_generator {
public:
  t_ts_generator(t_program* program,
                 const std::map<std::string, std::string>& parsed_options,
                 const std::string& option_string) : t_oop_generator(program) {
    (void)option_string;

    // TODO: support for immutable.js?
    for(std::map<std::string, std::string>::const_iterator iter = parsed_options.begin(); iter != parsed_options.end(); ++iter) {
      // if( iter->first.compare("abc") == 0) {
      // } else {
        throw "unknown option ts:" + iter->first;
      // }
    }

    out_dir_base_ = "gen-ts";

    escape_['\''] = "\\'";
  }

  /**
   * Init and close methods
   */

  void init_generator();
  void close_generator();

  /**
   * Program-level generation functions
   */

  void generate_typedef(t_typedef* ttypedef);
  void generate_enum(t_enum* tenum);
  void generate_const(t_const* tconst);
  void generate_struct(t_struct* tstruct);
  void generate_xception(t_struct* txception);
  void generate_service(t_service* tservice);

  /**
   * Render functions
   */

  std::string render_literal(t_type* type, t_const_value* value);
  void render_struct(std::ostream& out, t_struct* tstruct, bool is_exception = false);
  void render_struct_constructor(ostream& out, t_struct* tstruct, bool is_exception);
  void render_struct_field(ostream& out, t_struct* tstruct, t_field* field, bool is_exception, int32_t maxkey);
  void render_struct_reader(ostream& out, t_struct* tstruct);
  void render_value_reader(ostream& out, const string &src, t_type* type);
  void render_struct_writer(ostream& out, t_struct* tstruct);
  void render_value_writer(ostream& out, const string &src, t_type* type);

  void render_service_interface(t_service* tservice);
  void render_service_client(t_service* tservice);

  /**
   * Helper functions
   */

  std::string autogen_comment() {
    return std::string("//\n") + "// Autogenerated by Thrift Compiler (" + THRIFT_VERSION + ")\n"
           + "//\n" + "// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n"
           + "//\n";
  }

  string print_doc(t_doc* tdoc) {
    string result = "";

    if (tdoc->has_doc()) {
      std::stringstream doc(tdoc->get_doc());
      string item;

      result += "/**" + endl;
      while (std::getline(doc, item)) {
        result += indent() + " * " + item + endl;
      }
      result += indent() + " */" + endl + indent();
    }
    return result;
  }

  string identifier(std::string const& name) {
    std::string str = name;
    if (str.empty()) {
      return str;
    }

    // tests rely on this
    assert(('A' < 'Z') && ('a' < 'z') && ('0' < '9'));

    // if the first letter is a number, we add an additional underscore in front of it
    char c = str.at(0);
    if (('0' <= c) && (c <= '9')) {
      str = "_" + str;
    }

    // following chars: letter, number or underscore
    for (size_t i = 0; i < str.size(); ++i) {
      c = str.at(i);
      if ((('A' > c) || (c > 'Z')) && (('a' > c) || (c > 'z')) && (('0' > c) || (c > '9'))
          && ('_' != c) && ('$' != c)) {
        str.replace(i, 1, "_");
      }
    }

    return str;
  }

  std::string foreign_namespace(t_program* p) {
    string result = "";

    if (p != program_ || !service_name_.empty()) {
      result = identifier(p->get_name()) + "_ttypes.";
    }
    return result;
  }

  std::string foreign_type(t_type* t, bool annotate = true) {
    t_type* tt = get_true_type(t);

    if (t->is_enum() || t->is_struct() || t->is_xception() || t->is_typedef()) {
      if (t->get_program()) {
        return foreign_namespace(t->get_program()) + t->get_name();
      }
      return t->get_name();
    } else if (tt->is_base_type()) {
      t_base_type::t_base tbase = ((t_base_type*)tt)->get_base();
      switch (tbase) {
      case t_base_type::TYPE_STRING:
        return "string";
      case t_base_type::TYPE_BOOL:
        return "boolean";
      case t_base_type::TYPE_I8:
        return annotate ? "number/*i8*/" :  "number";
      case t_base_type::TYPE_I16:
        return annotate ? "number/*i16*/" :  "number";
      case t_base_type::TYPE_I32:
        return annotate ? "number/*i32*/" :  "number";
      case t_base_type::TYPE_I64:
        return annotate ? "number/*i64*/" :  "number";
      case t_base_type::TYPE_DOUBLE:
        return annotate ? "number/*double*/" :  "number";
      case t_base_type::TYPE_VOID:
        return "void";
      }
    } else if (tt->is_list() || tt->is_set()) {
      t_type* etype = t->is_list() ? ((t_list*)t)->get_elem_type() : ((t_set*)t)->get_elem_type();

      return foreign_type(etype, annotate) + "[]";
    } else if (tt->is_map()) {
      string ktype = foreign_type(((t_map*)t)->get_key_type(), false);
      string ktype2 = foreign_type(((t_map*)t)->get_key_type(), annotate);
      string vtype = foreign_type(((t_map*)t)->get_val_type(), false);
      string vtype2 = foreign_type(((t_map*)t)->get_val_type(), annotate);

      if (ktype == "number" || ktype == "string" ) {
        return "{ [k: " + ktype2 + "]: " + vtype2 + " }";
      } else if ((((t_map*)t)->get_key_type())->is_enum()) {
        // Not yet supported (enum map): https://github.com/Microsoft/TypeScript/pull/2652
        //ts_type = "{ [k: " + ktype + "]: " + vtype + "; }";
        if (annotate) {
          return "{ [k: number/*" + ktype + "*/]: " + vtype2 + " }";
        }
        return "{ [k: number]: " + vtype2 + " }";
      } else {
        if (annotate) {
          return "any/*{ [k: " + ktype + "]: " + vtype + " }*/";
        }
      }
    }
    return "any";
  }

  string type_to_enum(t_type* type) {
    type = get_true_type(type);

    if (type->is_base_type()) {
      t_base_type::t_base tbase = ((t_base_type*)type)->get_base();
      switch (tbase) {
      case t_base_type::TYPE_VOID:
        throw "NO T_VOID CONSTRUCT";
      case t_base_type::TYPE_BOOL:
        return "Thrift.TType.BOOL";
      case t_base_type::TYPE_I8:
        return "Thrift.TType.BYTE";
      case t_base_type::TYPE_I16:
        return "Thrift.TType.I16";
      case t_base_type::TYPE_I32:
        return "Thrift.TType.I32";
      case t_base_type::TYPE_I64:
        return "Thrift.TType.I64";
      case t_base_type::TYPE_DOUBLE:
        return "Thrift.TType.DOUBLE";
      case t_base_type::TYPE_STRING:
        return "Thrift.TType.STRING";
      }
    } else if (type->is_enum()) {
      return "Thrift.TType.I32";
    } else if (type->is_list()) {
      return "Thrift.TType.LIST";
    } else if (type->is_map()) {
      return "Thrift.TType.MAP";
    } else if (type->is_set()) {
      return "Thrift.TType.SET";
    } else if (type->is_struct() || type->is_xception()) {
      return "Thrift.TType.STRUCT";
    }
    throw "INVALID TYPE IN type_to_enum: " + type->get_name();
  }

private:
  ofstream_with_content_based_conditional_update f_types_;
  ofstream_with_content_based_conditional_update f_service_;
};

void t_ts_generator::init_generator() {
  string outdir = get_out_dir();
  MKDIR(outdir.c_str());

  string f_types_name = outdir + program_->get_name() + "_types.ts";
  f_types_.open(f_types_name.c_str());

  f_types_ << autogen_comment();
  f_types_ << endl;

  f_types_ << "import * as Thrift from './thrift';" << endl;

  const vector<t_program*>& includes = program_->get_includes();

  for (vector<t_program*>::const_iterator c_iter = includes.begin(); c_iter != includes.end(); ++c_iter) {
    f_types_ << "import * as  " << identifier((*c_iter)->get_name()) << "_ttypes from './" << (*c_iter)->get_name() << "_types';" << endl;
  }
  f_types_ << endl;

  f_types_ << "let throwRequired = Thrift.TProtocolException.throwRequired;" << endl;
  f_types_ << endl;

  f_types_ << "let isNull = (value: any) => value === undefined || value === null;" << endl;
  f_types_ << endl;
}

void t_ts_generator::close_generator() {
  f_types_.close();
}

void t_ts_generator::generate_typedef(t_typedef* ttypedef) {
  f_types_ << print_doc(ttypedef) << "export type " << identifier(ttypedef->get_symbolic()) << " = " << foreign_type(ttypedef->get_type()) << ";" << endl << endl;
}

void t_ts_generator::generate_enum(t_enum* tenum) {
  const vector<t_enum_value*> constants = tenum->get_constants();

  f_types_ << print_doc(tenum) << "export enum " << identifier(tenum->get_name()) << " {" << endl;

  indent_up();
  for (vector<t_enum_value*>::const_iterator c_iter = constants.begin(); c_iter != constants.end(); ++c_iter) {
    indent(f_types_) << identifier((*c_iter)->get_name()) << " = " << (*c_iter)->get_value() << "," << endl;
  }
  indent_down();

  f_types_ << "}" << endl << endl;
}

void t_ts_generator::generate_const(t_const* tconst) {
  f_types_ << print_doc(tconst) << "const " << identifier(tconst->get_name()) << ": " << foreign_type(tconst->get_type()) << " = " << render_literal(tconst->get_type(), tconst->get_value()) << ";" << endl << endl;
}

void t_ts_generator::generate_struct(t_struct* tstruct) {
  render_struct(f_types_, tstruct, false);
}

void t_ts_generator::generate_xception(t_struct* txception) {
  render_struct(f_types_, txception, true);
}

void t_ts_generator::generate_service(t_service* tservice) {
  string outdir = get_out_dir();
  MKDIR(outdir.c_str());

  string f_service_name = outdir + service_name_ + ".ts";
  f_service_.open(f_service_name.c_str());

  f_service_ << autogen_comment();
  f_service_ << endl;

  f_service_ << "import * as Thrift from './thrift';" << endl;

  const vector<t_program*>& includes = program_->get_includes();

  f_service_ << "import * as  " << identifier(program_->get_name()) << "_ttypes from './" << program_->get_name() << "_types';" << endl;
  for (vector<t_program*>::const_iterator c_iter = includes.begin(); c_iter != includes.end(); ++c_iter) {
    f_service_ << "import * as  " << identifier((*c_iter)->get_name()) << "_ttypes from './" << (*c_iter)->get_name() << "_types';" << endl;
  }
  f_service_ << endl;

  f_service_ << "let throwRequired = Thrift.TProtocolException.throwRequired;" << endl;
  f_service_ << endl;

  f_service_ << "let isNull = (value: any) => value === undefined || value === null;" << endl;
  f_service_ << endl;

  render_service_interface(tservice);
  render_service_client(tservice);

  f_service_.close();
}


string t_ts_generator::render_literal(t_type* type, t_const_value* value) {
  std::ostringstream out;
  t_type* ttype = get_true_type(type);

  if (ttype->is_base_type()) {
    t_base_type::t_base tbase = ((t_base_type*)ttype)->get_base();
    switch (tbase) {
    case t_base_type::TYPE_STRING:
      out << "'" << get_escaped_string(value) << "'";
      break;
    case t_base_type::TYPE_BOOL:
      out << (value->get_integer() > 0 ? "true" : "false");
      break;
    case t_base_type::TYPE_I8:
    case t_base_type::TYPE_I16:
    case t_base_type::TYPE_I32:
    case t_base_type::TYPE_I64:
      out << value->get_integer();
      break;
    case t_base_type::TYPE_DOUBLE:
      if (value->get_type() == t_const_value::CV_INTEGER) {
        out << value->get_integer();
      } else {
        out << emit_double_as_string(value->get_double());
      }
      break;
    default:
      throw "compiler error: cannot generate const of type " + type->get_name();
    }
  } else if (type->is_enum()) {
    out << value->get_identifier();
  } else if (type->is_struct() || type->is_xception()) {
    const vector<t_field*>& members = ((t_struct*)type)->get_members();
    vector<t_field*>::const_iterator m_iter;
    const map<t_const_value*, t_const_value*, t_const_value::value_compare>& val = value->get_map();
    map<t_const_value*, t_const_value*, t_const_value::value_compare>::const_iterator v_iter;
    bool first = true;

    out << "new " << foreign_type(type) << "(";
    for (m_iter = members.begin(); m_iter != members.end(); ++m_iter) {
      if ((*m_iter)->get_req() == t_field::T_OPTIONAL) {
        continue;
      }
      t_const_value* value = NULL;

      for (v_iter = val.begin(); v_iter != val.end(); ++v_iter) {
        if ((*m_iter)->get_name() == v_iter->first->get_string()) {
          value = v_iter->second;
        }
      }
      if (!first) {
        out << ", ";
      }
      first = false;
      if (value != NULL) {
        out << render_literal((*m_iter)->get_type(), value);
      } else {
        out << "undefined";
      }
    }
    for (m_iter = members.begin(); m_iter != members.end(); ++m_iter) {
      if ((*m_iter)->get_req() != t_field::T_OPTIONAL) {
        continue;
      }
      t_const_value* value = NULL;

      for (v_iter = val.begin(); v_iter != val.end(); ++v_iter) {
        if ((*m_iter)->get_name() == v_iter->first->get_string()) {
          value = v_iter->second;
        }
      }
      if (!first) {
        out << ", ";
      }
      first = false;
      if (value != NULL) {
        out << render_literal((*m_iter)->get_type(), value);
      } else {
        out << "undefined";
      }
    }
    indent(out) << ")";
  } else if (type->is_map()) {
    const map<t_const_value*, t_const_value*, t_const_value::value_compare>& val = value->get_map();
    t_type* ktype = ((t_map*)type)->get_key_type();
    t_type* vtype = ((t_map*)type)->get_val_type();

    out << "{";
    indent_up();
    for (map<t_const_value*, t_const_value*, t_const_value::value_compare>::const_iterator v_iter = val.begin(); v_iter != val.end(); ++v_iter) {
      out << endl << indent() << render_literal(ktype, v_iter->first) << ": " << render_literal(vtype, v_iter->second) << ",";
    }
    if (!val.empty()) {
      out << endl;
    }
    indent_down();
    indent(out) << "}";
  } else if (type->is_list() || type->is_set()) {
    const vector<t_const_value*>& val = value->get_list();
    t_type* etype = type->is_list() ? ((t_list*)type)->get_elem_type() : ((t_set*)type)->get_elem_type();

    out << "[";
    indent_up();
    for (vector<t_const_value*>::const_iterator v_iter = val.begin(); v_iter != val.end(); ++v_iter) {
      out << endl << indent() << render_literal(etype, *v_iter) << ",";
    }
    if (!val.empty()) {
      out << endl;
    }
    indent_down();
    out << "]";
  } else {
    throw "compiler error: unsupported type " + type->get_name();
  }
  return out.str();
}

void t_ts_generator::render_struct(ostream& out, t_struct* tstruct, bool is_exception) {
  out << "export class " << identifier(tstruct->get_name());
  if (is_exception) {
    out << " extends Thrift.TException";
  }
  out << " {" << endl;
  indent_up();

  render_struct_constructor(out, tstruct, is_exception);
  render_struct_reader(out, tstruct);
  render_struct_writer(out, tstruct);

  indent_down();
  out << "}" << endl << endl;
}

void t_ts_generator::render_struct_constructor(ostream& out, t_struct* tstruct, bool is_exception) {
  const vector<t_field*>& members = tstruct->get_members();
  vector<t_field*>::const_iterator m_iter;

  const vector<t_field*>& smembers = tstruct->get_sorted_members();
  int32_t maxkey = smembers.empty() ? 0 : smembers.back()->get_key();
  bool hasmessage = false;

  indent(out) << "constructor(";
  indent_up();
  for (m_iter = members.begin(); m_iter != members.end(); ++m_iter) {
    if (is_exception && identifier((*m_iter)->get_name()) == "message") {
      hasmessage = true;
    }
    if ((*m_iter)->get_req() != t_field::T_REQUIRED) {
      continue;
    }
    render_struct_field(out, tstruct, *m_iter, is_exception, maxkey);
  }
  for (m_iter = members.begin(); m_iter != members.end(); ++m_iter) {
    if ((*m_iter)->get_req() != t_field::T_OPT_IN_REQ_OUT) {
      continue;
    }
    render_struct_field(out, tstruct, *m_iter, is_exception, maxkey);
  }
  for (m_iter = members.begin(); m_iter != members.end(); ++m_iter) {
    if ((*m_iter)->get_req() != t_field::T_OPTIONAL) {
      continue;
    }
    render_struct_field(out, tstruct, *m_iter, is_exception, maxkey);
  }
  if (!members.empty()) {
    out << endl << indent();
  }
  indent_down();
  out << ") {" << endl;
  indent_up();
  if (is_exception) {
    indent(out) << "super(";
    if (hasmessage) {
      out << "message";
    }
    out << ");" << endl;
  }
  indent_down();
  indent(out) << "}" << endl << endl;
}

void t_ts_generator::render_struct_field(ostream& out, t_struct* tstruct, t_field* field, bool is_exception, int32_t maxkey) {
  (void)tstruct;

  int32_t n = (int32_t)ceilf(log10f(maxkey)) + 1;
  std::ostringstream id;

  id << field->get_key() << ":";
  while (id.tellp() < n) {
    id << " ";
  }

  out << endl << print_doc(field) << indent();
  switch (field->get_req()) {
  case t_field::T_REQUIRED:
    out << "/*" << id.str() << "required*/ ";
    break;
  case t_field::T_OPTIONAL:
    out << "/*" << id.str() << "optional*/ ";
    break;
  case t_field::T_OPT_IN_REQ_OUT:
    out << "/*" << id.str() << "reqout  */ ";
    break;
  }
  out << "public " << identifier(field->get_name());

  t_type* t = get_true_type(field->get_type());
  if (field->get_value() != NULL && !(t->is_struct() || t->is_xception())) {
    out << ": " << foreign_type(field->get_type());
    out << " = " << render_literal(field->get_type(), field->get_value());
  } else if (is_exception && identifier(field->get_name()) == "message") {
    out << ": " << foreign_type(field->get_type()) << " = ''";
  } else {
    out << "?: " << foreign_type(field->get_type());
  }
  out << ",";
}

void t_ts_generator::render_struct_reader(ostream& out, t_struct* tstruct) {
  const vector<t_field*>& members = tstruct->get_members();
  vector<t_field*>::const_iterator m_iter;

  out << endl;
  indent(out) << "read(__input: Thrift.TProtocol, data: Thrift.TStruct): " << identifier(tstruct->get_name()) << " {" << endl;
  indent_up();

  if (!members.empty()) {
    indent(out) << "let field: Thrift.TField;" << endl;
  }
  for (m_iter = members.begin(); m_iter != members.end(); ++m_iter) {
    t_field* field = *m_iter;
    t_type* type = field->get_type();

    indent(out) << "field = data.getField(" << field->get_key() << ", " << type_to_enum(type) << ");" << endl;
    indent(out) << "if (field) {" << endl;
    indent_up();
    indent(out) << "this." << identifier(field->get_name()) << " = ";
    render_value_reader(out, "field", type);
    out << ";" << endl;
    indent_down();
    indent(out) << "} else {" << endl;
    indent_up();
    switch (field->get_req()) {
    case t_field::T_REQUIRED:
      indent(out) << "throwRequired();" << endl;
      break;
    case t_field::T_OPTIONAL:
    case t_field::T_OPT_IN_REQ_OUT:
      indent(out) << "delete this." << identifier(field->get_name()) << ";" << endl;
      break;
    }
    indent_down();
    indent(out) << "}" << endl;
  }

  indent(out) << "return this;" << endl;
  indent_down();
  indent(out) << "}" << endl;
}

void t_ts_generator::render_value_reader(ostream& out, const string &src, t_type* type) {
  t_type* ttype = get_true_type(type);

  if (ttype->is_base_type()) {
    t_base_type::t_base tbase = ((t_base_type*)ttype)->get_base();
    switch (tbase) {
    case t_base_type::TYPE_STRING:
      out << src << ".stringValue";
      break;
    case t_base_type::TYPE_BOOL:
      out << src << ".booleanValue";
      break;
    case t_base_type::TYPE_I8:
    case t_base_type::TYPE_I16:
    case t_base_type::TYPE_I32:
    case t_base_type::TYPE_I64:
    case t_base_type::TYPE_DOUBLE:
      out << src << ".numberValue";
      break;
    default:
      throw "compiler error: cannot generate reader for type " + type->get_name();
    }
  } else if (type->is_enum()) {
    // FIXME: cast to enum / check validity?
    out << src << ".numberValue as " + foreign_type(type);
  } else if (type->is_list()) {
    t_type* etype = ((t_list*)type)->get_elem_type();

    out << src << ".listValue.map( (value) => { return ";
    render_value_reader(out, "value", etype);
    out << "; } )";
  } else if (type->is_map()) {
    string ktype = foreign_type(((t_map*)type)->get_key_type(), false);
    string vtype = foreign_type(((t_map*)type)->get_val_type(), false);

    if (ktype == "number" || ((t_map*)type)->get_key_type()->is_enum()) {
      out << src << ".mapValue.mapNumber( (key) => key.numberValue, (value) => ";
      render_value_reader(out, "value", ((t_map*)type)->get_val_type());
      out << " )";
    } else if (ktype == "string") {
      out << src << ".mapValue.mapString( (key) => key.stringValue, (value) => ";
      render_value_reader(out, "value", ((t_map*)type)->get_val_type());
      out << " )";
    } else {
      out << src << ".mapValue.mapGeneric( (key) => ";
      render_value_reader(out, "key", ((t_map*)type)->get_key_type());
      out << ", (value) => ";
      render_value_reader(out, "value", ((t_map*)type)->get_val_type());
      out << " )";
    }
  } else if (type->is_set()) {
    t_type* etype = ((t_set*)type)->get_elem_type();

    out << src << ".setValue.map( (value) => ";
    render_value_reader(out, "value", etype);
    out << " )";
  } else if (type->is_struct() || type->is_xception()) {
    out << "new " << foreign_type(type) << "().read(__input, " << src << ".structValue)";
  } else {
    throw "compiler error: unsupported type " + ttype->get_name();
  }
}

void t_ts_generator::render_struct_writer(ostream& out, t_struct* tstruct) {
  const vector<t_field*>& members = tstruct->get_members();
  vector<t_field*>::const_iterator m_iter;

  out << endl;
  indent(out) << "write(__output: Thrift.TProtocol): Thrift.TStruct {" << endl;
  indent_up();

  indent(out) << "let fields: { [k: number]: Thrift.TField } = {};" << endl;
  for (m_iter = members.begin(); m_iter != members.end(); ++m_iter) {
    t_field* field = *m_iter;
    t_type* type = field->get_type();

    indent(out) << "if (!isNull(this." << identifier(field->get_name()) << ")) {" << endl;
    indent_up();
    indent(out) << "fields[" << field->get_key() << "] = ";
    render_value_writer(out, "this." + identifier(field->get_name()), type);
    out << ".asField();" << endl;
    switch (field->get_req()) {
    case t_field::T_REQUIRED:
      indent_down();
      indent(out) << "} else {" << endl;
      indent_up();
      indent(out) << "throwRequired();" << endl;
      break;
    case t_field::T_OPTIONAL:
    case t_field::T_OPT_IN_REQ_OUT:
      break;
    }
    indent_down();
    indent(out) << "}" << endl;
  }

  indent(out) << "return new Thrift.TStruct(fields);" << endl;
  indent_down();
  indent(out) << "}" << endl;
}

void t_ts_generator::render_value_writer(ostream& out, const string &src, t_type* type) {
  t_type* ttype = get_true_type(type);

  if (ttype->is_base_type()) {
    t_base_type::t_base tbase = ((t_base_type*)ttype)->get_base();
    switch (tbase) {
    case t_base_type::TYPE_STRING:
      out << "Thrift.TBase.newString(" << src << ")";
      break;
    case t_base_type::TYPE_BOOL:
      out << "Thrift.TBase.newBool(" << src << ")";
      break;
    case t_base_type::TYPE_I8:
      out << "Thrift.TBase.newI08(" << src << ")";
      break;
    case t_base_type::TYPE_I16:
      out << "Thrift.TBase.newI16(" << src << ")";
      break;
    case t_base_type::TYPE_I32:
      out << "Thrift.TBase.newI32(" << src << ")";
      break;
    case t_base_type::TYPE_I64:
      out << "Thrift.TBase.newI64(" << src << ")";
      break;
    case t_base_type::TYPE_DOUBLE:
      out << "Thrift.TBase.newDouble(" << src << ")";
      break;
    default:
      throw "compiler error: cannot generate writer of type " + type->get_name();
    }
  } else if (type->is_enum()) {
    out << "Thrift.TBase.newI32(" << src << " as number)";
  } else if (type->is_list()) {
    t_type* etype = ((t_list*)type)->get_elem_type();

    out << "Thrift.TList.newList(" << type_to_enum(etype) << ", " << src << ", (value) => ";
    render_value_writer(out, "value", etype);
    out << " )";
  } else if (type->is_map()) {
    t_type* ktype = ((t_map*)type)->get_key_type();
    t_type* vtype = ((t_map*)type)->get_val_type();
    string ktype2 = foreign_type(((t_map*)type)->get_key_type(), false);
    string vtype2 = foreign_type(((t_map*)type)->get_val_type(), false);

    out << "Thrift.TMap.newMap<" << ktype2 << ", " << vtype2 << ">(" << type_to_enum(ktype) << ", " << type_to_enum(vtype) << ", " << src << ", (key) => ";
    render_value_writer(out, "key", ktype);
    out << ", (value) => ";
    render_value_writer(out, "value", vtype);
    out << " )";
  } else if (type->is_set()) {
    t_type* etype = ((t_set*)type)->get_elem_type();

    out << "Thrift.TSet.newSet(" << type_to_enum(etype) << ", " << src << ", (value) => ";
    render_value_writer(out, "value", etype);
    out << " )";
  } else if (type->is_struct() || type->is_xception()) {
    out << src << ".write(__output)";
  } else {
    throw "compiler error: unsupported type " + ttype->get_name();
  }
}

void t_ts_generator::render_service_interface(t_service* tservice) {
  f_service_ << "export interface " << identifier(service_name_);
  if (tservice->get_extends() != NULL) {
    f_service_ << " extends " << foreign_type(tservice->get_extends());
  }
  f_service_ << " {" << endl;
  indent_up();

  vector<t_function*> functions = tservice->get_functions();
  vector<t_function*>::const_iterator f_iter;

  for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
    t_struct* arg_struct = (*f_iter)->get_arglist();
    const vector<t_field*>& fields = arg_struct->get_members();
    vector<t_field*>::const_iterator fld_iter;
    t_type* rettype = (*f_iter)->get_returntype();
    bool first = true;

    indent(f_service_) << print_doc(*f_iter) << identifier((*f_iter)->get_name()) << "(";
    for (fld_iter = fields.begin(); fld_iter != fields.end(); ++fld_iter) {
      if (!first) {
        f_service_ << ", ";
      }
      first = false;
      f_service_ << identifier((*fld_iter)->get_name()) << ": " << foreign_type((*fld_iter)->get_type());
    }
    f_service_ << "): Promise<" << foreign_type(rettype) << ">;" << endl << endl;
  }

  indent_down();
  f_service_ << "}" << endl << endl;
}

void t_ts_generator::render_service_client(t_service* tservice) {
  f_service_ << "export class " << identifier(service_name_) + "Client";
  if (tservice->get_extends() != NULL) {
    f_service_ << " extends " << foreign_type(tservice->get_extends()) + "Client";
  }
  f_service_ << " implements " << identifier(service_name_) << " {" << endl;
  indent_up();

  indent(f_service_) << "private seqid: number = 0;" << endl << endl;

  indent(f_service_) << "constructor(readonly input: Thrift.TProtocol, readonly output: Thrift.TProtocol) {";
  indent_up();
  if (tservice->get_extends() != NULL) {
    indent(f_service_) << "super(input, output);" << endl;
  }
  indent_down();
  indent(f_service_) << "}" << endl << endl;

  vector<t_function*> functions = tservice->get_functions();
  vector<t_function*>::const_iterator f_iter;

  for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
    t_struct* arg_struct = (*f_iter)->get_arglist();
    const vector<t_field*>& fields = arg_struct->get_members();
    vector<t_field*>::const_iterator fld_iter;
    t_type* rettype = (*f_iter)->get_returntype();
    bool first = true;

    indent(f_service_) << print_doc(*f_iter) << identifier((*f_iter)->get_name()) << "(";
    for (fld_iter = fields.begin(); fld_iter != fields.end(); ++fld_iter) {
      if (!first) {
        f_service_ << ", ";
      }
      first = false;
      f_service_ << identifier((*fld_iter)->get_name()) << ": " << foreign_type((*fld_iter)->get_type());
    }
    f_service_ << "): Promise<" << foreign_type(rettype) << "> {" << endl;
    indent_up();

    indent(f_service_) << "let __input = this.input;" << endl;
    indent(f_service_) << "let __output = this.output;" << endl;
    indent(f_service_) << "let __params: { [k: number]: Thrift.TField } = {};" << endl;
    for (fld_iter = fields.begin(); fld_iter != fields.end(); ++fld_iter) {
      indent(f_service_) << "if (!isNull(" << identifier((*fld_iter)->get_name()) << ")) {" << endl;
      indent_up();
      indent(f_service_) << "__params[" << (*fld_iter)->get_key() << "] = ";
      render_value_writer(f_service_, identifier((*fld_iter)->get_name()), (*fld_iter)->get_type());
      f_service_ << ".asField();" << endl;
      indent_down();
      indent(f_service_) << "}" << endl;
    }
    if ((*f_iter)->is_oneway()) {
      indent(f_service_) << "return __output.writeMessage(new Thrift.TMessage('" << (*f_iter)->get_name() << "', Thrift.TMessageType.CALL, this.seqid, new Thrift.TStruct(__params)));" << endl;
    } else {
      indent(f_service_) << "return __output.writeMessage(new Thrift.TMessage('" << (*f_iter)->get_name() << "', Thrift.TMessageType.CALL, this.seqid, new Thrift.TStruct(__params)))" << endl;
      indent_up();
      indent(f_service_) << ".then( _ => __input.readMessage() )" << endl;
      indent(f_service_) << ".then( message => {" << endl;
      indent_up();

      indent(f_service_) << "switch (message.messageType) {" << endl;
      indent_up();

      indent(f_service_) << "case Thrift.TMessageType.REPLY:" << endl;
      indent_up();
      indent(f_service_) << "return ";
      if (foreign_type(rettype) != "void") {
        render_value_reader(f_service_, "message.value", rettype);
      }
      f_service_ << ";" << endl;
      indent_down();

      indent(f_service_) << "case Thrift.TMessageType.EXCEPTION:" << endl;
      indent_up();
      indent(f_service_) << "throw new Thrift.TApplicationException().read(__input, message.structValue);" << endl;
      indent_down();

      indent(f_service_) << "default:" << endl;
      indent_up();
      indent(f_service_) << "throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, 'invalid message type');" << endl;
      indent_down();

      indent_down();
      indent(f_service_) << "}" << endl;

      indent_down();
      indent(f_service_) << "});" << endl;
      indent_down();
    }

    indent_down();
    indent(f_service_) << "}" << endl << endl;
  }

  indent_down();
  f_service_ << "}" << endl << endl;
}


THRIFT_REGISTER_GENERATOR(ts,
                          "TypeScript",
                          "")
